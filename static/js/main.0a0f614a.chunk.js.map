{"version":3,"sources":["App.js","main.js","reportWebVitals.js","index.js"],"names":["App","useEffect","SCENE","THREE","CAMERA","window","innerWidth","innerHeight","RENDERER","canvas","document","querySelector","alpha","setPixelRatio","devicePixelRatio","setSize","position","setZ","render","GEOMETRY","MATERIAL","color","TORUS","add","POINT_LIGHT","set","AMBIENT_LIGHT","LIGHT_HELPER","GRID_HELPER","CONTROLS","OrbitControls","domElement","Array","fill","forEach","STAR","map","randFloatSpread","x","y","z","load","texture","xhr","console","log","loaded","total","animate","requestAnimationFrame","rotation","update","ThreeD","id","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"yNAkBeA,MAdf,WAME,OAJFC,qBAAU,YCHK,WAEb,IAAMC,EAAQ,IAAIC,IAGZC,EAAS,IAAID,IAAwB,GAAIE,OAAOC,WAAaD,OAAOE,YAAa,GAAK,KAGtFC,EAAW,IAAIL,IAAoB,CACvCM,OAAQC,SAASC,cAAc,OAC/BC,OAAO,IAITJ,EAASK,cAAcR,OAAOS,kBAG9BN,EAASO,QAAQV,OAAOC,WAAYD,OAAOE,aAG3CH,EAAOY,SAASC,KAAK,IAIrBT,EAASU,OAAOhB,EAAME,GAStB,IAAMe,EAAW,IAAIhB,IAAoB,GAAI,EAAG,GAAI,KAS9CiB,EAAW,IAAIjB,IAA2B,CAC9CkB,MAAO,QAIHC,EAAQ,IAAInB,IAAWgB,EAASC,GAEtClB,EAAMqB,IAAID,GAKV,IAAME,EAAc,IAAIrB,IAAiB,UACzCqB,EAAYR,SAASS,IAAI,EAAE,EAAE,GAG7B,IAAMC,EAAgB,IAAIvB,IAAmB,UAE7CD,EAAMqB,IAAIC,EAAaE,GAGvB,IAAMC,EAAe,IAAIxB,IAAuBqB,GAE1CI,EAAc,IAAIzB,IAAiB,IAAK,IAC9CD,EAAMqB,IAAII,EAAcC,GAIxB,IAAMC,EAAW,IAAIC,IAAc1B,EAAQI,EAASuB,YAgBpDC,MAAM,KAAKC,OAAOC,SAblB,WACE,IAAMf,EAAW,IAAIhB,IAAqB,KACpCiB,EAAW,IAAIjB,IAA2B,CAC9CkB,MAAO,WAEHc,EAAO,IAAIhC,IAAWgB,EAAUC,GACtC,EAAkBY,MAAM,GAAGC,OAAOG,KAAI,kBAAMjC,IAAgBkC,gBAAgB,QAA5E,mBAAOC,EAAP,KAAUC,EAAV,KAAaC,EAAb,KAEAL,EAAKnB,SAASS,IAAIa,EAAGC,EAAGC,GAExBtC,EAAMqB,IAAIY,OAOiB,IAAIhC,KAEZsC,KAEjB,4CAEA,SAAEC,GACiB,IAAIvC,IAAyB,CAAEuC,eAIlD,SAAEC,GACEC,QAAQC,IAAMF,EAAIG,OAASH,EAAII,MAAQ,IAAO,eAGlD,SAAEJ,GACEC,QAAQC,IAAK,yBASa,IAAI1C,KAEZsC,KACtB,kDAEA,SAAEC,GACe,IAAIvC,IACnB,IAAIA,IAAkB,EAAE,EAAE,GAC1B,IAAIA,IAAyB,CAAEiC,IAAKM,QAItC,SAAEC,GACEC,QAAQC,IAAMF,EAAIG,OAASH,EAAII,MAAQ,IAAO,eAGlD,SAAEJ,GACEC,QAAQC,IAAK,wBAOrB,SAASG,IACPC,sBAAsBD,GACtB1B,EAAM4B,SAASZ,GAAK,IACpBhB,EAAM4B,SAASX,GAAK,KACpBjB,EAAM4B,SAASV,GAAK,IAEpBX,EAASsB,SAET3C,EAASU,OAAOhB,EAAME,GAGxB4C,GDlJAI,MAIG,sBAAKC,GAAG,YAAR,UACG,wBAAQA,GAAG,OACX,qBAAKA,GAAG,cAAR,4BEDOC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCFdQ,IAAS7C,OACP,cAAC,IAAM8C,WAAP,UACE,cAAC,EAAD,MAEFtD,SAASuD,eAAe,SAM1BX,M","file":"static/js/main.0a0f614a.chunk.js","sourcesContent":["import './style.css';\nimport {useEffect} from 'react';\nimport ThreeD from './main';\n\nfunction App() {\n\nuseEffect(() => {\n  ThreeD();\n})\n\n  return (\n     <div id=\"container\">\n        <canvas id=\"bg\"></canvas>\n        <div id=\"canvas-text\">three d!!!</div>\n    </div>\n  );\n}\n\nexport default App;\n","import * as THREE from \"../node_modules/three\"\nimport { OrbitControls } from '../node_modules/three/examples/jsm/controls/OrbitControls';\n\nexport default function ThreeD() {\n  // scene = objects, cameras, and lights\n  const SCENE = new THREE.Scene();\n  \n  // camera = mimics what the human eye would see. First argument determines the field of view / amount of world that's visible in a 360 view. Second argument is the aspect ratio based off of the users browser window. Third argument is the view frustrum that determines what is visible to the camera itself\n  const CAMERA = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\n  // renderer = gives the render method parameters to follow when drawing\n  const RENDERER = new THREE.WebGLRenderer({\n    canvas: document.querySelector(\"#bg\"),\n    alpha: true, // needed to make the draw space clear initially\n  });\n\n  // pixel ratio = user window pixel ratio\n  RENDERER.setPixelRatio(window.devicePixelRatio);\n\n  // size = user window size\n  RENDERER.setSize(window.innerWidth, window.innerHeight);\n\n  // since we're starting at the middle of the page, moving along the z-axis gives the user a looking up through to down motion when scrolling\n  CAMERA.position.setZ(30);\n\n  // render = draw/write/paint/create and display\n\n  RENDERER.render(SCENE,CAMERA);\n\n\n  /* ADDING AN OBJECT BELOW\n  ************************************** \n  */\n\n\n  // geometry = set of vectors to generate shape\n  const GEOMETRY = new THREE.TorusGeometry(10, 3, 16, 100);\n\n  // material = the visual representation of the geometry\n  /* const MATERIAL = new THREE.MeshBasicMaterial({\n      color: 0xaaffaa,\n      wireframe: true,\n  */\n  // the above gives a mesh with wireframe that doesn't need lighting to diplay when drawn\n\n  const MATERIAL = new THREE.MeshStandardMaterial({\n    color: 0x00ff00,\n  })\n\n  // set object to be created based on prior parameters\n  const TORUS = new THREE.Mesh(GEOMETRY,MATERIAL);\n\n  SCENE.add(TORUS);\n\n  // add light to the scene so that standard material becomes visible\n  // PointLight is like a regular buld light source that lights up the entire room\n\n  const POINT_LIGHT = new THREE.PointLight(0xffffff);\n  POINT_LIGHT.position.set(5,5,5); //sets the point of the light source via x,y,z coordinates. Larger numbers = further out from the center\n\n  // ambient light add a flood light to the entire room/scene equally\n  const AMBIENT_LIGHT = new THREE.AmbientLight(0xffffff);\n\n  SCENE.add(POINT_LIGHT, AMBIENT_LIGHT);\n\n  // PointLightHelper shows the position of a point light\n  const LIGHT_HELPER = new THREE.PointLightHelper(POINT_LIGHT);\n  // GridHelper shows where an object lies on the grid via drawing a 2D grid\n  const GRID_HELPER = new THREE.GridHelper(200, 50);\n  SCENE.add(LIGHT_HELPER, GRID_HELPER);\n\n  // OrbitControls allows us to move throughout the 3D space\n  // The folling listens for dom elements focused on by the mouse (onMouseDown) and updates the camera accordingly\n  const CONTROLS = new OrbitControls(CAMERA, RENDERER.domElement);\n\n  // creates random stars throughout the grid space\n  function addStar() {\n    const GEOMETRY = new THREE.SphereGeometry(0.25);\n    const MATERIAL = new THREE.MeshStandardMaterial({\n      color: 0xffffff,\n    })\n    const STAR = new THREE.Mesh(GEOMETRY, MATERIAL);\n    const [x, y, z] = Array(3).fill().map(() => THREE.MathUtils.randFloatSpread(100));\n    \n    STAR.position.set(x, y, z);\n\n    SCENE.add(STAR);\n  }\n\n  Array(200).fill().forEach(addStar);\n\n  // another way to add an image to the background\n  function addBackground() {\n    const BACKGROUND_TEXTURE = new THREE.TextureLoader();\n    \n    BACKGROUND_TEXTURE.load(\n\n      'pexels-francesco-ungaro-998641-space.jpg',\n\n      ( texture ) => {\n        let background = new THREE.MeshBasicMaterial( { texture } );\n      },\n      // can pass a callback function here as well to show a status bar for assets being loaded\n      // Function called when download progresses\n      ( xhr ) => {\n          console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );\n      },\n      // Function called when download errors\n      ( xhr ) => {\n          console.log( 'An error happened' );\n      }\n\n    );\n  }\n\n  addBackground();\n\n  function addBridge() {\n    const BROOKLYN_BRIDGE_TEXTURE = new THREE.TextureLoader();\n\n    BROOKLYN_BRIDGE_TEXTURE.load(\n      'three_d_react/src/WP_20170822_13_13_37_Pro.jpg',\n\n      ( texture ) => {\n        const BRIDGE = new THREE.Mesh(\n        new THREE.BoxGeometry(3,3,3),\n        new THREE.MeshBasicMaterial( { map: texture } )\n        );\n      },\n      // Function called when download progresses\n      ( xhr ) => {\n          console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );\n      },\n      // Function called when download errors\n      ( xhr ) => {\n          console.log( 'An error happened' );\n      }\n    )\n  }\n\n  addBridge();\n\n  function animate() {\n    requestAnimationFrame(animate);\n    TORUS.rotation.x += 0.01;\n    TORUS.rotation.y += 0.005;\n    TORUS.rotation.z += 0.01;\n\n    CONTROLS.update(); // reflects changes (onMouseUp) in the UI as new start point for the next change (onMouseDown) \n\n    RENDERER.render(SCENE,CAMERA);\n  };\n\n  animate();\n\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}